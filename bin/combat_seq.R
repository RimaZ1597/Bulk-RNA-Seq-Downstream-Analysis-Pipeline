#!/usr/bin/env Rscript

# ComBat-seq Batch Correction Script
# Compatible with setup.py configuration output
# 
# Usage with Nextflow pipeline (recommended):
#   Via main.nf pipeline with analysis_config.yaml from setup.py
#
# Direct usage:
#   Rscript combat_seq.R --counts counts.csv --metadata metadata.csv --config analysis_config.yaml --output_dir ./

# Load required libraries
suppressPackageStartupMessages({
    library(sva)          # ComBat-seq batch correction
    library(yaml)         # Configuration file parsing
    library(argparse)     # Command line argument parsing
})

# Parse command line arguments
parser <- ArgumentParser(description='ComBat-seq batch correction for RNA-seq data')
parser$add_argument('--counts', required=TRUE, 
                   help='Path to counts matrix CSV file (genes as rows, samples as columns)')
parser$add_argument('--metadata', required=TRUE, 
                   help='Path to sample metadata CSV file (compatible with setup.py output)')
parser$add_argument('--config', required=TRUE, 
                   help='Path to analysis_config.yaml file (from setup.py)')
parser$add_argument('--output_dir', default='.', 
                   help='Output directory for corrected data and plots')
args <- parser$parse_args()

cat("\n=== ComBat-seq Batch Correction Analysis ===\n")
cat("Generated by: setup.py RNA-seq configuration wizard\n")
cat("Timestamp:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n\n")

cat("Input Parameters:\n")
cat("  Counts matrix:", args$counts, "\n")
cat("  Sample metadata:", args$metadata, "\n")
cat("  Configuration:", args$config, "\n")
cat("  Output directory:", args$output_dir, "\n\n")

# Load configuration from setup.py
cat("Loading analysis configuration from setup.py...\n")
tryCatch({
    config <- yaml::read_yaml(args$config)
}, error = function(e) {
    stop("Failed to load configuration file: ", e$message)
})

# Extract experimental design parameters
batch_factor <- config$experimental_design$batch_factor
primary_factor <- config$experimental_design$primary_factor
additional_factors <- config$experimental_design$additional_factors
project_name <- config$project_name

# Validate batch correction is requested
# Check batch correction setting
perform_batch_correction <- config$analysis_parameters$perform_batch_correction
if (is.null(perform_batch_correction)) {
    perform_batch_correction <- FALSE
}

if (!perform_batch_correction) {
    cat("⚠️  Batch correction disabled - performing gene filtering only\n")
} else {
    cat("✅ Batch correction enabled - performing gene filtering + ComBat-seq\n")
}

cat("Experimental Design Configuration:\n")
cat("  Project:", project_name, "\n")
cat("  Primary factor:", primary_factor, "\n")
cat("  Batch factor:", ifelse(is.null(batch_factor), "None", batch_factor), "\n")
cat("  Additional factors:", ifelse(length(additional_factors) > 0, paste(additional_factors, collapse=", "), "None"), "\n\n")

# === INTELLIGENT BATCH VALIDATION ===
# Check if batch correction should be performed
skip_combat <- FALSE
batch_correction_reason <- "Unknown"

# First check if batch correction is disabled in configuration
if (!perform_batch_correction) {
    skip_combat <- TRUE
    batch_correction_reason <- "Batch correction disabled in configuration"
    cat("⚠️  Batch correction disabled in configuration - will skip ComBat-seq correction\n")
    cat("   → Will perform gene filtering only\n\n")
} else if (is.null(batch_factor) || batch_factor == "None" || batch_factor == "") {
    skip_combat <- TRUE
    batch_correction_reason <- "No batch factor specified"
    cat("⚠️  No batch factor specified - will skip ComBat-seq correction\n")
    cat("   → Using gene-filtered counts for downstream analysis\n\n")
}

# Load count matrix (setup.py format: genes as rows, samples as columns)
cat("Loading count matrix...\n")
tryCatch({
    counts_df <- read.csv(args$counts, row.names = 1, check.names = FALSE)
    # Ensure all values are numeric
    counts_df <- as.data.frame(lapply(counts_df, function(x) as.numeric(as.character(x))))
    rownames(counts_df) <- rownames(read.csv(args$counts, row.names = 1))
}, error = function(e) {
    stop("Failed to load counts matrix: ", e$message)
})

cat("  Dimensions:", nrow(counts_df), "genes x", ncol(counts_df), "samples\n")
cat("  Sample names:", paste(head(colnames(counts_df), 3), collapse=", "), "...\n")

# Load sample metadata (setup.py format)
cat("Loading sample metadata...\n")
tryCatch({
    metadata_df <- read.csv(args$metadata, row.names = 1, stringsAsFactors = FALSE, check.names = FALSE)
}, error = function(e) {
    stop("Failed to load metadata: ", e$message)
})

cat("  Samples in metadata:", nrow(metadata_df), "\n")
cat("  Available factors:", paste(colnames(metadata_df), collapse=", "), "\n\n")

# Validate sample matching between counts and metadata
cat("Validating sample consistency...\n")
counts_samples <- colnames(counts_df)
metadata_samples <- rownames(metadata_df)

if (!all(counts_samples %in% metadata_samples)) {
    missing_samples <- setdiff(counts_samples, metadata_samples)
    stop("Samples in counts matrix not found in metadata: ", paste(missing_samples, collapse=", "))
}

if (!all(metadata_samples %in% counts_samples)) {
    missing_samples <- setdiff(metadata_samples, counts_samples)
    cat("  Warning: Some metadata samples not in counts matrix:", paste(missing_samples, collapse=", "), "\n")
}

# Align samples (keep only common samples in same order)
common_samples <- intersect(counts_samples, metadata_samples)
counts_matrix <- as.matrix(counts_df[, common_samples])
metadata_aligned <- metadata_df[common_samples, ]

cat("  Final dataset:", nrow(counts_matrix), "genes x", ncol(counts_matrix), "samples\n\n")

# === DATASET OVERVIEW (like setup.py) ===
cat("=== DATASET OVERVIEW ===\n")
cat("Detected categorical fields with levels:\n")

# Get all categorical/factor columns from metadata
for (col_name in colnames(metadata_aligned)) {
    col_data <- metadata_aligned[[col_name]]
    
    # Check if column has reasonable number of unique values for categorical display
    unique_values <- unique(col_data)
    if (length(unique_values) <= 20 && length(unique_values) > 1) {  # Show if 2-20 unique values
        cat(" →", col_name, ":", paste0("['", paste(unique_values, collapse="', '"), "']"), "\n")
        
        # Show sample counts per level
        value_counts <- table(col_data)
        for (i in seq_along(value_counts)) {
            value_name <- names(value_counts)[i]
            count <- as.numeric(value_counts)[i]
            cat("    -", value_name, ":", count, ifelse(count == 1, "sample", "samples"), "\n")
        }
    }
}
cat("\n")

# Validate required factors exist in metadata
required_factors <- c(primary_factor)
if (!skip_combat && !is.null(batch_factor)) {
    required_factors <- c(required_factors, batch_factor)
}
if (!is.null(additional_factors) && length(additional_factors) > 0) {
    required_factors <- c(required_factors, additional_factors)
}

missing_factors <- setdiff(required_factors, colnames(metadata_aligned))
if (length(missing_factors) > 0) {
    stop("Required factors not found in metadata: ", paste(missing_factors, collapse=", "))
}

if (skip_combat) {
    cat("  Primary factor found in metadata (batch correction will be skipped)\n\n")
} else {
    cat("  All required factors found in metadata\n\n")
}

# Prepare condition vector (always needed)
condition_vector <- as.factor(metadata_aligned[[primary_factor]])

if (!skip_combat) {
    # Prepare batch and condition vectors for batch analysis
    batch_vector <- as.factor(metadata_aligned[[batch_factor]])

    cat("Batch Effect Analysis:\n")
    cat("  Batch factor levels:", paste(levels(batch_vector), collapse=", "), "\n")
    cat("  Sample distribution across batches:\n")
    batch_table <- table(batch_vector)
    print(batch_table)
    cat("\n  Condition factor levels:", paste(levels(condition_vector), collapse=", "), "\n")
    cat("  Sample distribution across conditions:\n")
    print(table(condition_vector))
    cat("\n  Cross-tabulation (Condition x Batch):\n")
    print(table(condition_vector, batch_vector))
    cat("\n")
} else {
    cat("Condition Analysis (no batch correction):\n")
    cat("  Condition factor levels:", paste(levels(condition_vector), collapse=", "), "\n")
    cat("  Sample distribution across conditions:\n")
    print(table(condition_vector))
    cat("\n")
}

# === COMBAT-SEQ BATCH CORRECTION ANALYSIS ===
cat("=== BATCH CORRECTION DECISION ANALYSIS ===\n")

if (!skip_combat) {
    # Analyze batch sizes for ComBat-seq viability
    min_samples_per_batch <- min(batch_table)
    cat("Minimum samples per batch:", min_samples_per_batch, "\n")
    cat("ComBat-seq requirement: ≥2 samples per batch\n")

    # Identify problematic batches
    single_sample_batches <- names(batch_table)[batch_table == 1]
    if (length(single_sample_batches) > 0) {
        cat("Batches with only 1 sample:", paste(single_sample_batches, collapse=", "), "\n")
    }

    if (min_samples_per_batch < 2) {
        cat("\n⚠️  DECISION: ComBat-seq SKIPPED\n")
        cat("   Reason: Statistical limitation - ComBat-seq requires ≥2 samples per batch\n")
        cat("   Impact: Will use filtered counts without batch correction\n")
        cat("   Alternative: Consider merging batches or using other batch correction methods\n\n")
        
        skip_combat <- TRUE
        batch_correction_reason <- "Insufficient samples per batch"
    } else {
        cat("\n✅ DECISION: ComBat-seq APPLICABLE\n")
        cat("   All batches have ≥2 samples - proceeding with batch correction\n\n")
        skip_combat <- FALSE
        batch_correction_reason <- "Batch correction applicable"
    }
} else {
    cat("⚠️  DECISION: ComBat-seq SKIPPED\n")
    cat("   Reason:", batch_correction_reason, "\n")
    cat("   Impact: Will use filtered counts without batch correction\n\n")
}

# Filter low count genes before batch correction
cat("Filtering low count genes...\n")

# Apply filtering based on setup.py configuration with group-aware enhancement
if (!is.null(config$filtering_config)) {
    filtering_method <- config$filtering_config$method
    threshold <- config$filtering_config$threshold
    min_samples <- config$filtering_config$min_samples
    
    if (!is.null(min_samples) && is.numeric(min_samples)) {
        # CPM-based filtering for limma-voom
        if (filtering_method == "limma-voom") {
            cpm_matrix <- edgeR::cpm(counts_matrix)
            keep_genes <- rowSums(cpm_matrix >= threshold) >= min_samples
            cat("  Method: CPM-based filtering (limma-voom)\n")
            cat("  Threshold: CPM >=", threshold, "in >=", min_samples, "samples\n")
        } else {
            # Count-based filtering for DESeq2
            keep_genes <- rowSums(counts_matrix >= threshold) >= min_samples
            cat("  Method: Count-based filtering (DESeq2)\n")
            cat("  Threshold: >=", threshold, "counts in >=", min_samples, "samples\n")
        }
    } else {
        # Enhanced default: Group-aware filtering (RStudio approach)
        condition_table <- table(condition_vector)
        smallest_group_size <- min(condition_table)
        
        keep_genes <- rowSums(counts_matrix >= 10) >= smallest_group_size
        cat("  Method: Group-aware filtering (enhanced default)\n")
        cat("  Threshold: >=10 counts in >=", smallest_group_size, "samples (smallest group size)\n")
        cat("  Groups:", paste(names(condition_table), "=", condition_table, collapse=", "), "\n")
    }
    
    counts_filtered <- counts_matrix[keep_genes, ]
    cat("  Filtered from", nrow(counts_matrix), "to", nrow(counts_filtered), "genes\n")
} else {
    # Enhanced default: Group-aware filtering instead of simple total
    condition_table <- table(condition_vector)
    smallest_group_size <- min(condition_table)
    
    keep_genes <- rowSums(counts_matrix >= 10) >= smallest_group_size
    counts_filtered <- counts_matrix[keep_genes, ]
    cat("  Applied group-aware filtering: >=10 counts in >=", smallest_group_size, "samples\n")
    cat("  Groups:", paste(names(condition_table), "=", condition_table, collapse=", "), "\n")
    cat("  Filtered from", nrow(counts_matrix), "to", nrow(counts_filtered), "genes\n")
}

# Create design matrix for ComBat-seq
cat("Creating design matrix...\n")

# Validate factors have sufficient variation before adding to design
valid_factors <- c()

# Check primary factor
primary_levels <- length(unique(metadata_aligned[[primary_factor]]))
if (primary_levels >= 2) {
    valid_factors <- c(valid_factors, primary_factor)
    cat("  ✅ Primary factor '", primary_factor, "' has ", primary_levels, " levels - included\n", sep="")
} else {
    cat("  ⚠️  Primary factor '", primary_factor, "' has only ", primary_levels, " level - EXCLUDED from design\n", sep="")
}

# Check additional factors for variation and confounding with batch factor
excluded_factors <- c()
confounded_factors <- c()

if (!is.null(additional_factors) && length(additional_factors) > 0) {
    for (factor_name in additional_factors) {
        if (factor_name %in% colnames(metadata_aligned)) {
            factor_levels <- length(unique(metadata_aligned[[factor_name]]))
            if (factor_levels >= 2) {
                # Check for confounding with batch factor
                if (!is.null(batch_factor) && batch_factor %in% colnames(metadata_aligned)) {
                    # Create cross-tabulation to check confounding
                    cross_tab <- table(metadata_aligned[[factor_name]], metadata_aligned[[batch_factor]])
                    
                    # Count how many combinations have zero samples (indicating potential confounding)
                    zero_combinations <- sum(cross_tab == 0)
                    total_combinations <- nrow(cross_tab) * ncol(cross_tab)
                    confounding_ratio <- zero_combinations / total_combinations
                    
                    # If >50% of combinations are empty, consider it confounded
                    if (confounding_ratio > 0.5) {
                        confounded_factors <- c(confounded_factors, factor_name)
                        cat("  ⚠️  Additional factor '", factor_name, "' has ", factor_levels, " levels but is CONFOUNDED with batch factor '", batch_factor, "' - EXCLUDED\n", sep="")
                        cat("      → ", zero_combinations, "/", total_combinations, " factor combinations are empty (", round(confounding_ratio*100, 1), "%)\n", sep="")
                    } else {
                        valid_factors <- c(valid_factors, factor_name)
                        cat("  ✅ Additional factor '", factor_name, "' has ", factor_levels, " levels - included\n", sep="")
                    }
                } else {
                    # No batch factor to check confounding against
                    valid_factors <- c(valid_factors, factor_name)
                    cat("  ✅ Additional factor '", factor_name, "' has ", factor_levels, " levels - included\n", sep="")
                }
            } else {
                excluded_factors <- c(excluded_factors, factor_name)
                cat("  ⚠️  Additional factor '", factor_name, "' has only ", factor_levels, " level - EXCLUDED from design\n", sep="")
            }
        } else {
            excluded_factors <- c(excluded_factors, factor_name)
            cat("  ⚠️  Additional factor '", factor_name, "' not found in metadata - EXCLUDED from design\n", sep="")
        }
    }
}

# Report exclusions
all_excluded <- c(excluded_factors, confounded_factors)
if (length(all_excluded) > 0) {
    reason_map <- c()
    if (length(excluded_factors) > 0) reason_map <- c(reason_map, paste(excluded_factors, "(insufficient variation)"))
    if (length(confounded_factors) > 0) reason_map <- c(reason_map, paste(confounded_factors, "(confounded with batch)"))
    cat("  ➤ Excluded factors: ", paste(reason_map, collapse=", "), "\n", sep="")
}

# Build design formula with valid factors only
if (length(valid_factors) > 0) {
    design_formula <- paste("~", paste(valid_factors, collapse=" + "))
} else {
    # Fallback: intercept-only model if no valid factors
    design_formula <- "~ 1"
    cat("  ⚠️  Warning: No factors with sufficient variation - using intercept-only model\n")
}

cat("  Final design formula:", design_formula, "\n")

# Test design matrix creation and check for rank deficiency
tryCatch({
    design_matrix <- model.matrix(as.formula(design_formula), data=metadata_aligned)
    matrix_rank <- qr(design_matrix)$rank
    matrix_cols <- ncol(design_matrix)
    
    cat("  Design matrix dimensions:", nrow(design_matrix), "x", matrix_cols, "\n")
    cat("  Design matrix rank:", matrix_rank, "/", matrix_cols)
    
    if (matrix_rank < matrix_cols) {
        cat(" - RANK DEFICIENT (confounded!)\n")
        # Fall back to primary factor only
        if (primary_factor %in% valid_factors && length(unique(metadata_aligned[[primary_factor]])) >= 2) {
            cat("  ➤ Falling back to primary factor only: ", primary_factor, "\n", sep="")
            design_formula <- paste("~", primary_factor)
            design_matrix <- model.matrix(as.formula(design_formula), data=metadata_aligned)
            cat("  Simplified design matrix dimensions:", nrow(design_matrix), "x", ncol(design_matrix), "\n")
        } else {
            # Last resort: intercept-only model
            cat("  ➤ Using intercept-only model due to confounding\n")
            design_formula <- "~ 1"
            design_matrix <- model.matrix(as.formula(design_formula), data=metadata_aligned)
        }
    } else {
        cat(" - FULL RANK (good!)\n")
    }
    
}, error = function(e) {
    cat("  ❌ Error creating design matrix:", e$message, "\n")
    # Fall back to intercept-only model
    design_formula <- "~ 1"
    design_matrix <- model.matrix(as.formula(design_formula), data=metadata_aligned)
    cat("  Using intercept-only fallback model\n")
})

cat("\n")

# Perform ComBat-seq batch correction (if applicable)
if (!skip_combat) {
    cat("Performing ComBat-seq batch correction...\n")
    cat("  This may take several minutes for large datasets...\n")

    start_time <- Sys.time()
    combat_success <- FALSE
    
    tryCatch({
        # Try ComBat-seq with the designed covariates
        corrected_counts <- ComBat_seq(
            counts = as.matrix(counts_filtered),
            batch = batch_vector,
            group = condition_vector,
            covar_mod = design_matrix[, -1, drop=FALSE]  # Remove intercept
        )
        end_time <- Sys.time()
        cat("  ✅ ComBat-seq completed successfully in", round(difftime(end_time, start_time, units="mins"), 2), "minutes\n\n")
        combat_success <- TRUE
        
    }, error = function(e) {
        cat("  ❌ ComBat-seq failed with covariates:", e$message, "\n")
        
        # Check if it's a confounding error - try with simplified design
        if (grepl("confounded", e$message, ignore.case=TRUE)) {
            cat("  ➤ Attempting ComBat-seq without additional covariates (condition-only)...\n")
            
            tryCatch({
                # Try with minimal design (just condition factor)
                corrected_counts <<- ComBat_seq(
                    counts = as.matrix(counts_filtered),
                    batch = batch_vector,
                    group = condition_vector
                    # No covar_mod - let ComBat-seq handle it automatically
                )
                end_time <- Sys.time()
                cat("  ✅ ComBat-seq completed with simplified design in", round(difftime(end_time, start_time, units="mins"), 2), "minutes\n")
                cat("  ➤ Note: Additional covariates were excluded due to confounding\n\n")
                combat_success <<- TRUE
                
            }, error = function(e2) {
                cat("  ❌ ComBat-seq failed even with simplified design:", e2$message, "\n")
                cat("  ➤ DECISION: Skipping ComBat-seq due to experimental design constraints\n")
                cat("     Will use filtered counts without batch correction\n\n")
                skip_combat <<- TRUE
                batch_correction_reason <<- "Experimental design confounding prevents batch correction"
            })
        } else {
            # Non-confounding error - still skip
            cat("  ➤ DECISION: Skipping ComBat-seq due to processing error\n")
            cat("     Will use filtered counts without batch correction\n\n")
            skip_combat <<- TRUE
            batch_correction_reason <<- paste("ComBat-seq processing error:", e$message)
        }
    })
    
    # Update skip_combat flag based on success
    if (!combat_success) {
        skip_combat <- TRUE
    }
} else {
    cat("Skipping ComBat-seq batch correction - using filtered counts as final output.\n\n")
}

# Save corrected data
cat("Saving final count matrix...\n")

# Determine which counts to use
if (!skip_combat && combat_success && exists("corrected_counts")) {
    # Use ComBat-seq corrected counts
    final_counts <- corrected_counts
    cat("  Using ComBat-seq batch-corrected counts\n")
    method_used <- "ComBat-seq (Applied)"
} else {
    # Use original filtered counts
    final_counts <- as.matrix(counts_filtered)
    cat("  Using filtered counts (ComBat-seq skipped)\n")
    method_used <- "ComBat-seq (Skipped)"
}

# === QUALITY CONTROL ASSESSMENT ===
cat("\n=== Quality Check ===\n")

# Basic statistics comparison
original_lib_sizes <- colSums(counts_filtered)
final_lib_sizes <- colSums(final_counts)

cat("Library size statistics:\n")
cat("  Original (filtered) - Min:", min(original_lib_sizes), "Max:", max(original_lib_sizes), "Median:", median(original_lib_sizes), "\n")
cat("  Final (output) - Min:", min(final_lib_sizes), "Max:", max(final_lib_sizes), "Median:", median(final_lib_sizes), "\n")

# Library size preservation check
lib_size_change <- abs(final_lib_sizes - original_lib_sizes) / original_lib_sizes * 100
cat("  Library size changes - Mean:", round(mean(lib_size_change), 2), "% Max:", round(max(lib_size_change), 2), "%\n")

if (!skip_combat && combat_success && exists("corrected_counts")) {
    cat("  Assessment: ComBat-seq applied - library sizes", 
        ifelse(mean(lib_size_change) < 1, "well preserved", 
               ifelse(mean(lib_size_change) < 5, "moderately preserved", "significantly changed")), "\n")
} else {
    cat("  Assessment: No batch correction applied - library sizes identical to filtered counts\n")
}

# Gene-level statistics
cat("Gene expression statistics:\n")
original_gene_means <- rowMeans(counts_filtered)
final_gene_means <- rowMeans(final_counts)
cat("  Original gene means - Min:", round(min(original_gene_means), 2), "Max:", round(max(original_gene_means), 2), "\n")
cat("  Final gene means - Min:", round(min(final_gene_means), 2), "Max:", round(max(final_gene_means), 2), "\n")

# Correlation between original and corrected
gene_correlation <- cor(original_gene_means, final_gene_means)
cat("  Gene-level correlation (original vs final):", round(gene_correlation, 4), "\n")

if (!skip_combat && combat_success && exists("corrected_counts")) {
    cat("  Assessment: Gene expression", 
        ifelse(gene_correlation > 0.95, "highly preserved", 
               ifelse(gene_correlation > 0.9, "well preserved", "moderately preserved")), 
        "after batch correction\n")
}

cat("\n")

# Save counts based on whether ComBat-seq was applied
original_counts_df <- as.data.frame(counts_filtered)
final_counts_df <- as.data.frame(final_counts)

if (!skip_combat && combat_success && exists("corrected_counts")) {
    # ComBat-seq was applied - save both original and corrected
    write.csv(final_counts_df, file.path(args$output_dir, "combatseq_corrected_counts.csv"), 
              row.names=TRUE, quote=FALSE)
    cat("  ✓ ComBat-seq corrected counts saved to: combatseq_corrected_counts.csv\n")
    
    # Also save original filtered counts for comparison
    write.csv(original_counts_df, file.path(args$output_dir, "filtered_counts.csv"), 
              row.names=TRUE, quote=FALSE)
    cat("  ✓ Original filtered counts saved to: filtered_counts.csv\n")
} else {
    # ComBat-seq was skipped - only save filtered counts (no 'corrected' file since no correction was done)
    write.csv(final_counts_df, file.path(args$output_dir, "filtered_counts.csv"), 
              row.names=TRUE, quote=FALSE)
    cat("  ✓ Filtered counts saved to: filtered_counts.csv\n")
}

# Always save original counts for Nextflow module compatibility (expected output)
write.csv(original_counts_df, file.path(args$output_dir, "combatseq_original_counts.csv"), 
          row.names=TRUE, quote=FALSE)
cat("  ✓ Original counts saved to: combatseq_original_counts.csv\n")

# Save metadata (unchanged)
write.csv(metadata_aligned, file.path(args$output_dir, "combatseq_metadata.csv"), 
          row.names=TRUE, quote=FALSE)
cat("  ✓ Metadata saved to: combatseq_metadata.csv\n")

# Create summary log
log_content <- c(
    paste("ComBat-seq Batch Correction Summary"),
    paste("===================================="),
    paste("Timestamp:", format(Sys.time(), "%Y-%m-%d %H:%M:%S")),
    paste(""),
    paste("Input Data:"),
    paste("  Original genes:", nrow(counts_matrix)),
    paste("  Filtered genes:", nrow(counts_filtered)),
    paste("  Samples:", ncol(counts_filtered)),
    paste(""),
    paste("Experimental Design:"),
    paste("  Project:", project_name),
    paste("  Primary factor:", primary_factor),
    paste("  Batch factor:", batch_factor),
    paste("  Additional factors:", paste(additional_factors, collapse=", ")),
    paste(""),
    paste("Batch Correction:"),
    if (!skip_combat && combat_success && exists("corrected_counts")) {
        c(paste("  Method:", method_used),
          paste("  Batch levels:", paste(levels(batch_vector), collapse=", ")),
          paste("  Condition levels:", paste(levels(condition_vector), collapse=", ")))
    } else {
        c(paste("  Method:", method_used),
          paste("  Reason:", batch_correction_reason),
          paste("  Output: Filtered counts used directly"))
    },
    paste(""),
    paste("Quality Control:"),
    paste("  Library size changes - Mean:", paste0(round(mean(lib_size_change), 2), "%"), "Max:", paste0(round(max(lib_size_change), 2), "%")),
    paste("  Gene correlation (original vs final):", round(gene_correlation, 4)),
    if (!skip_combat && combat_success && exists("corrected_counts")) {
        c(paste("  Library size preservation:", 
                ifelse(mean(lib_size_change) < 1, "Excellent", 
                       ifelse(mean(lib_size_change) < 5, "Good", "Fair"))),
          paste("  Gene expression preservation:", 
                ifelse(gene_correlation > 0.95, "Excellent", 
                       ifelse(gene_correlation > 0.9, "Good", "Fair"))))
    } else {
        paste("  No batch correction applied - data unchanged")
    },
    paste(""),
    paste("Output Files:"),
    if (!skip_combat && combat_success && exists("corrected_counts")) {
        c(paste("  combatseq_corrected_counts.csv - ComBat-seq batch-corrected counts"),
          paste("  filtered_counts.csv - Original filtered counts (before correction)"))
    } else {
        paste("  filtered_counts.csv - Gene-filtered counts (ComBat-seq skipped)")
    },
    paste("  combatseq_original_counts.csv - Original counts (for pipeline compatibility)"),
    paste("  combatseq_metadata.csv - Sample metadata"),
    paste("  combatseq_log.txt - Analysis summary log")
)

writeLines(log_content, file.path(args$output_dir, "combatseq_log.txt"))
cat("  ✓ Analysis log saved to: combatseq_log.txt\n")

# Write combatseq_applied flag for pipeline integration
combatseq_applied_flag <- (!skip_combat && combat_success && exists("corrected_counts"))
writeLines(ifelse(combatseq_applied_flag, "true", "false"), 
          file.path(args$output_dir, "combatseq_applied.txt"))
cat("  ✓ ComBat-seq applied flag saved to: combatseq_applied.txt (", 
    ifelse(combatseq_applied_flag, "true", "false"), ")\n")

if (!skip_combat && combat_success && exists("corrected_counts")) {
    cat("\n=== ComBat-seq Batch Correction Completed Successfully ===\n")
} else {
    cat("\n=== Batch Processing Completed (ComBat-seq Skipped) ===\n")
}
cat("Output files saved to:", args$output_dir, "\n")
cat("Use combatseq_corrected_counts.csv for downstream differential expression analysis.\n\n")